import {
  Center,
  Heading,
  HStack,
  VStack,
  Switch,
  Text,
  TextArea,
  IconButton,
  Button,
  ScrollView,
  FormControl,
  WarningOutlineIcon,
  Input,
} from "native-base";

import { AntDesign } from "@expo/vector-icons";
import { IItemPutAndPost } from "../../@types/item";
import {
  useApp,
  useEffect,
  useForm,
  useNavigation,
  useRef,
  useState,
  useTranslation,
} from "../../hooks";
import { getProductByCode, postProduct } from "../../providers/useProduct";
import { formatCurrency } from "../../utils/generic";
import MaskInput, { Masks } from "react-native-mask-input";
import { useMutation, useQueryClient } from "react-query";
import { postOrPutItem } from "../../providers/useItemQuery";
import Container from "../../components/Container";
import ProductHistory from "../Product/ItemHistory";
import { yupResolver } from "@hookform/resolvers/yup";
import * as yup from "yup";
import { IProductPost } from "../../@types/product";

const AddItemScreen = ({ route }: any) => {
  const navigation = useNavigation();
  const { currentShoppingList } = useApp();
  const { code, previousScreen } = route.params;
  const {
    data: product,
    isLoading,
    isSuccess,
  } = getProductByCode(code, code != null);

  const [item, setItem] = useState<IItemPutAndPost>({
    note: "",
    quantity: 1,
    price: 0,
    perUnit: 0,
    added: true,
    product: {
      code: code,
    },
    shoppingList: {
      id: currentShoppingList ? currentShoppingList?.id : "",
    },
  });
  const { t } = useTranslation();
  const queryClient = useQueryClient();
  const inputProductDescRef = useRef(null);
  const inputProductBrandRef = useRef(null);
  const inputProductCodeRef = useRef(null);
  const [isAutoGeneratedCode, setAutoGeneratedCode] = useState(true);

  const {
    mutate: addItem,
    isLoading: isLoadingAdd,
    error: errorAdd,
  } = useMutation({
    mutationFn: (changeItem: IItemPutAndPost) => postOrPutItem(changeItem),
    onSuccess: async () => {
      await queryClient.invalidateQueries({ queryKey: ["shoppingLists"] });
      await queryClient.invalidateQueries({ queryKey: ["searchShoppingList"] });
      await queryClient.invalidateQueries({ queryKey: ["shoppingListById"] });
      if (previousScreen == "productSearch") {
        //@ts-ignore
        navigation.pop(2);
      } else {
        //@ts-ignore
        navigation.pop(1);
      }
    },
  });

  const {
    mutate: addProduct,
    isLoading: isLoadingAddProduct,
    error: errorAddProduct,
    data: productAdded,
  } = useMutation({
    mutationFn: (changeItem: IProductPost) => postProduct(changeItem),
    onSuccess: async () => {
      console.log("Product added");
    },
    onSettled(data, error, variables, context) {
      setItem({ ...item, product: { code: data.code } });
      addItem({ ...item, product: { code: data.code } });
    },
  });

  const fieldValidationSchema = yup.object().shape({
    perUnit: yup
      .number()
      .required(`${t("form_messages.message_required")}`)
      .min(0.01, `${t("form_messages.min_value", { min: "0,01" })}`),
    productDescription: yup
      .string()
      //.required(`${t("form_messages.message_required")}`)
      .min(3, `${t("form_messages.min_value", { min: "3" })}`),
    productBrand: yup.string(),
    productCode: yup
      .string()
      .min(3, `${t("form_messages.min_value", { min: "3" })}`),
  });

  const {
    register,
    setValue,
    handleSubmit,
    formState: { errors },
    clearErrors,
    trigger,
    getValues,
  } = useForm({ resolver: yupResolver(fieldValidationSchema) });

  useEffect(() => {
    if (code == null) {
      register("productDescription");
      register("productBrand");
      register("productCode");
    }
    register("perUnit");
  }, [register]);

  const onSubmit = (data: any) => {
    if (code == null) {
      addProduct({
        description: data.productDescription,
        brand: data.productBrand,
        code: data.productCode ? data.productCode : null,
      });
    } else {
      addItem({ ...item });
    }
  };

  return (
    <Container loading={isLoadingAdd} error={errorAdd} tryAgain={() => {}}>
      <Center>
        {!isLoading && (
          <ScrollView>
            <VStack marginTop={2} marginLeft={2} marginRight={2} space={5}>
              {code != null ? (
                <VStack space={2}>
                  <Heading size={"sm"}>{product?.items[0].description}</Heading>
                  <Heading size={"xs"}>{product?.items[0].brand}</Heading>
                  <Text>{product?.items[0].code}</Text>
                </VStack>
              ) : (
                <VStack space={2}>
                  <FormControl
                    alignItems={"flex-start"}
                    isInvalid={errors?.productDescription != undefined}
                  >
                    <Input
                      ref={inputProductDescRef}
                      autoCapitalize={"characters"}
                      autoFocus
                      bgColor="white"
                      _focus={{
                        selectionColor: "green",
                      }}
                      placeholder={`${t(
                        "form_messages.placeholder_product_name"
                      )}`}
                      onChangeText={(text) => {
                        clearErrors("productDescription");
                        setValue("productDescription", text.toUpperCase());
                        trigger("productDescription");
                      }}
                      onSubmitEditing={() => {
                        //@ts-ignore
                        inputProductBrandRef.current.focus();
                      }}
                      isDisabled={isLoading}
                    />
                    <FormControl.ErrorMessage
                      leftIcon={<WarningOutlineIcon size="xs" />}
                    >
                      {errors.productDescription?.message}
                    </FormControl.ErrorMessage>
                  </FormControl>
                  <FormControl
                    alignItems={"flex-start"}
                    isInvalid={errors?.productBrand != undefined}
                  >
                    <Input
                      ref={inputProductBrandRef}
                      autoCapitalize={"characters"}
                      bgColor="white"
                      _focus={{
                        selectionColor: "green",
                      }}
                      placeholder={`${t(
                        "form_messages.placeholder_product_brand"
                      )}`}
                      onChangeText={(text) => {
                        clearErrors("productBrand");
                        setValue("productBrand", text.toUpperCase());
                        trigger("productBrand");
                      }}
                      onSubmitEditing={() => {
                        //@ts-ignore
                        inputProductCodeRef?.current.focus();
                      }}
                      isDisabled={isLoading}
                      // value={getValues("description")}
                    />
                    <FormControl.ErrorMessage
                      leftIcon={<WarningOutlineIcon size="xs" />}
                    >
                      {errors.productBrand?.message}
                    </FormControl.ErrorMessage>
                  </FormControl>
                  <HStack>
                    <Heading justifyContent={"center"} size={"xs"}>
                      {t("form_messages.label_auto_generate_product_code")}
                    </Heading>
                    <Switch
                      justifyContent={"center"}
                      value={isAutoGeneratedCode}
                      onToggle={(value) => {
                        setAutoGeneratedCode(value);
                      }}
                    />
                  </HStack>
                  <FormControl
                    alignItems={"flex-start"}
                    isInvalid={errors?.productCode != undefined}
                  >
                    <Input
                      ref={inputProductCodeRef}
                      autoCapitalize={"characters"}
                      bgColor="white"
                      _focus={{
                        selectionColor: "green",
                      }}
                      placeholder={`${t(
                        "form_messages.placeholder_product_code"
                      )}`}
                      onChangeText={(text) => {
                        clearErrors("productCode");
                        setValue("productCode", text.toUpperCase());
                        trigger("productCode");
                      }}
                      onSubmitEditing={() => {}}
                      keyboardType={"numeric"}
                      isDisabled={isAutoGeneratedCode}
                      // value={getValues("description")}
                    />
                    <FormControl.ErrorMessage
                      leftIcon={<WarningOutlineIcon size="xs" />}
                    >
                      {errors.productCode?.message}
                    </FormControl.ErrorMessage>
                  </FormControl>
                </VStack>
              )}
              <HStack>
                <VStack w={"98%"}>
                  <Heading size={"xs"}>{t("form_messages.label_note")}</Heading>
                  <TextArea
                    autoCompleteType={false}
                    value={item.note}
                    onChangeText={(text) => {
                      setItem({ ...item, note: text });
                    }}
                  />
                </VStack>
              </HStack>

              <HStack justifyContent={"space-between"}>
                <VStack alignItems={"flex-start"}>
                  <Heading size={"xs"}>
                    {t("form_messages.label_is_added")}
                  </Heading>
                  <Switch
                    value={item.added}
                    onToggle={(value) => {
                      setItem({ ...item, added: value });
                    }}
                  />
                </VStack>
                <VStack alignItems={"center"}>
                  <Heading size={"xs"}>
                    {t("form_messages.label_quantity")}
                  </Heading>
                  <HStack space={2} justifyContent={"center"}>
                    <IconButton
                      size={"sm"}
                      variant="ghost"
                      _icon={{
                        as: AntDesign,
                        name: "minussquare",
                        color: "red.600",
                      }}
                      isDisabled={isLoading}
                      onPress={() => {
                        if (item.quantity > 0) {
                          const price = (
                            (item.quantity - 1) *
                            item.perUnit
                          ).toFixed(2);
                          setItem({
                            ...item,
                            quantity: item.quantity - 1,
                            price: parseFloat(price),
                          });
                        }
                      }}
                    />

                    <Heading marginTop={1} onPress={() => {}} size={"sm"}>
                      {item.quantity}
                    </Heading>

                    <IconButton
                      size={"sm"}
                      variant="ghost"
                      _icon={{
                        as: AntDesign,
                        name: "plussquare",
                        color: "green.600",
                      }}
                      isDisabled={isLoading}
                      onPress={() => {
                        const price = (
                          (item.quantity + 1) *
                          item.perUnit
                        ).toFixed(2);
                        setItem({
                          ...item,
                          quantity: item.quantity + 1,
                          price: parseFloat(price),
                        });
                      }}
                    />
                  </HStack>
                </VStack>
              </HStack>
              <HStack justifyContent={"space-between"}>
                <Heading size={"sm"}>{t("form_messages.label_total")}</Heading>
                <Heading size={"sm"}>{formatCurrency(item.price)}</Heading>
              </HStack>
              <HStack justifyContent={"center"}>
                <FormControl
                  alignItems={"center"}
                  isInvalid={errors?.perUnit != undefined}
                  w="100%"
                  maxW="300px"
                >
                  <MaskInput
                    autoFocus={code != null}
                    value={formatCurrency(item.perUnit)}
                    onChangeText={(masked: any, unmasked: any) => {
                      let newValue = (parseFloat(unmasked) * 0.01).toFixed(2);
                      let price = (
                        parseFloat(newValue) * item.quantity
                      ).toFixed(2);
                      setValue("perUnit", parseFloat(newValue));
                      setItem({
                        ...item,
                        perUnit: parseFloat(newValue),
                        price: parseFloat(price),
                      });
                    }}
                    keyboardType="numeric"
                    mask={Masks.BRL_CURRENCY}
                    onSubmitEditing={() => {}}
                    style={{
                      fontSize: 50,
                    }}
                  />
                  <FormControl.ErrorMessage
                    leftIcon={<WarningOutlineIcon size="xs" />}
                  >
                    {errors.perUnit?.message}
                  </FormControl.ErrorMessage>
                </FormControl>
              </HStack>

              <HStack justifyContent={"center"}>
                <ProductHistory product={product?.items[0]} />
              </HStack>

              <HStack justifyContent={"center"}>
                <Button
                  rounded={20}
                  w={"50%"}
                  isLoading={isLoadingAdd}
                  size={"lg"}
                  marginBottom={20}
                  onPress={handleSubmit(onSubmit)}
                >
                  {t("scan.button_add_item")}
                </Button>
              </HStack>
            </VStack>
          </ScrollView>
        )}
      </Center>
    </Container>
  );
};

export default AddItemScreen;
